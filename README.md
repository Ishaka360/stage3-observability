Stage 3 - Observability Documentation

Overview

This project implements an observability setup designed to monitor, log, and analyze the performance and status of applications deployed through Docker containers. The setup integrates NGINX as a reverse proxy server and a custom Python-based system watcher to provide continuous visibility into system health.

Project Description

The observability system captures logs from the NGINX reverse proxy, stores them in a Docker volume, and monitors the logs using a Python watcher container. The watcher checks for errors, uptime, and performance metrics, and can be extended to trigger alerts when predefined thresholds are exceeded. This ensures that system administrators can track real-time behavior and detect issues promptly.

System Architecture

The project uses Docker to orchestrate the components and enable communication between containers through a shared network. The architecture includes the NGINX container, which acts as the reverse proxy and generates access and error logs, and the System Watcher container, which reads the logs from a shared Docker volume and outputs health information in real time.

Project Files and Structure

The project directory contains configuration files, scripts, and supporting documentation.
.env and .env.example hold environment variables.
Dockerfile defines the image used to build the watcher service.
docker-compose.yml orchestrates the multi-container setup for NGINX and the watcher.
nginx.conf and nginx.conf.template define the NGINX server configuration.
watcher.py is the Python script that monitors system status and log activity.
requirements.txt lists Python dependencies.
runbook.md provides operational and troubleshooting instructions.
logs/system.log stores the system logs generated by NGINX.

Environment Configuration

The .env file contains environment variables such as the log file path, alert threshold, and email address for notifications. Before running the project, duplicate the .env.example file, rename it to .env, and update values as needed.

Example variables include:

LOG_FILE_PATH=./logs/system.log
ALERT_THRESHOLD=80
ALERT_EMAIL=admin@example.com

Docker Setup

To start the observability stack, run docker-compose up --build -d from the project root. This builds and starts both the NGINX and watcher containers.
To stop the containers, run docker-compose down.
The NGINX container listens on port 80 and serves as the primary entry point, while the watcher container continuously monitors the shared log volume for changes.

Log Monitoring

All logs generated by the NGINX container are stored in the logs directory. The System Watcher container reads and processes these logs in real time. It outputs system status indicators to confirm whether both services (Blue and Green) are operational. These logs are essential for diagnosing errors, analyzing performance, and ensuring uptime.

Runbook

The runbook.md file provides instructions on how to handle common operational issues, including restarting containers, investigating log errors, and verifying network configurations. It also contains guidelines for troubleshooting alert thresholds and scaling the observability setup.

Observability Workflow

The workflow begins with NGINX processing incoming requests and writing logs to the mounted volume. The watcher script, running in a separate container, accesses the same volume and monitors for anomalies or downtime. This setup creates a feedback loop where logs and performance data are continuously updated and analyzed to maintain visibility into the systemâ€™s behavior.

Requirements

To install the dependencies locally, run pip install -r requirements.txt. This ensures the Python watcher can execute outside of Docker if needed.

Version Control

The project can be version-controlled using Git. Initialize the repository, add files, commit changes, and push to your GitHub repository.
Example commands:
git init
git add .
git commit -m "Initial commit - stage3 observability setup"
git remote add origin https://github.com/Ishaka360/stage3-observability.git

git branch -M main
git push -u origin main
